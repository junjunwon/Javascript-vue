동기 : 위에서부터 한줄씩 실행되는 것
  - if, for도 동기식임

비동기식 : javascript에서 언제 실행될지 모르고, 코드 상의 순서대로 실행되지 않는 코드
  - eventlistener function 콜백함수

항상 데이터와 화면을 따로 생각하되 둘을 일치시키는 작업이 필요하다.

입력받은 hor, ver 값에 따라
동적으로 tr, td 생성!

클로저, 스코프, 프로토타입, 실행 컨테스트, 이벤트 루프 에 대해 공부

만약 서비스하게 되면 console은 전부 지워야한다. (성능, 보안 측면)

======================================================================================
데이터 딕셔너리화하기.
데이터 관리가 편하고 값에 대한 혼동이 오지 않는다.
지뢰를 X, 열어본 칸 : 1, 안열어본 칸 0
위와 같이 하면 나중에 X,1,0만 보고 코드를 이해해야되서 헤깔린다.
그래서 데이터를 딕셔너리화해서 사용하면 편리하다.
var 코드표={
  연칸 : -1,
  물음표 : -2,
  깃발 : -3,
  깃발지뢰 : -4,
  물음표지뢰 : -5,
  지뢰 : 1,
  보통칸 : 0,
}
과 같이 하고 사용할때는 코드표.연칸 (dictionary.key)와 같이 사용한다. 
======================================================================================
스코프
- 스코프는 결국 전역변수와 지역변수를 나뜻한다.

var name='zero';

function outer(){
  console.log('외부',name); //외부 zero
  function inner(){
    var enemy='nero';
    console.log('내부', name); //내부 zero
  }
  inner();
}
outer();
console.log(enemy); //Uncaught ReferenceError: enemy is not defined (enemy는 지역변수이기 때문.)
스코프 선언된 변수를 찾기 위해서는 해당 함수로부터 한단계 밖으로 나오면서 제일 큰 범위까지 확인해보기.
  - 여기서 전역(제일 큰 범위)에서도 선언된 변수를 찾지 못하면 에러 출력
  - 이와 같이 스코프간의 상하관계를 스코프체인이라고 부른다.
javascript는 코드를 적는 순간 이미 모든 변수가 무엇인지 다 결정이 되는 언어다, 스코프도 결정된다. -> 렉시컬 스코프
자바스크립트가 다이나믹하단 말이 있지만 스코프만은 정적이다. -> 
======================================================================================
클로저
  - 어떠한 관계를 말한다.
  - 함수와 함수가 선언된 어휘적 환경의 조합이다. (어휘적 === 렉시컬)
  - 함수와 함수가 접근할 수 있는 스코프가 클로저 관계를 맺는다.
  - 반복문과 비동기 함수가 만날때 클로저 문제가 자주 발생한다.

  문제
  for(var i=0; i<100; i++){
    setTimeout(function(){
        console.log(i); //i는 151번째 줄에 있는 var i=0;가 된다. 죽었다 깨어나도.
    }, i*1000);
}
        //위에 onsole.log(i)는 전부 100만 찍힌다. 
        // setTimeout : 비동기 코드
        // i가 100이 된 뒤에서야 i*1000코드로 인해 1초마다 100이 실행된다.
        // 해당 문제는 클로저 문제지만 클로저가 잘못된게 아니라 클로저의 성격을 활용해서 해결할 수 있다는 것.
        // for문은 callstack에서 이미 다 돌고 i가 다 증가된 상태로 setTimeout이 호출되서 이런 에러가 생기는 것.
  
해결책
  for(var i=0; i<100; i++){
    function closure(j){
      setTimeout(function(){
        console.log(j); //죽었다 꺠어나도 56번째 줄 j --> 0,1,2,3,4,....99
      }, j*1000);
    }
    closure(i);
  }

  함수 즉시 실행을 원할 경우 함수를 소괄호()로 감싸주고 함수호출하는 것처럼 하면 됨. 
  위 코드를 즉시 실행으로 바꿀 경우.
    (function closure(j){
      setTimeout(function(){
        console.log(j); //죽었다 꺠어나도 56번째 줄 j --> 0,1,2,3,4,....99
      }, j*1000);
    })(i);

======================================================================================

e.target : 실제로 eventlistener가 발생하는 대상.
e.currentTarget : eventlistener를 직접 달아놓은 대상.

======================================================================================

콜 스택

- 문제 : 함수 호출에 따른 출력 결과를 맞춰보시오.

function d(){
  console.log('d');
}
function e(){
  console.log('e');
}

function a(){
  function b(){
    function c(){
      console.log('c');
    }
    c();
    console.log('b');
  }
  b();
  console.log('a');
}

d();
e();
a();

내가 푼 답 : d e c c b c b a
정답 : d e c b a

==============================================
21.06.25 일지
프라미스
콜백함수
var / let / const
async / await